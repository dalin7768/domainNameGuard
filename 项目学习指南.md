# 域名监控项目学习指南

## 项目架构概览

```
域名监控系统
├── 配置层 (config_manager.py)
│   └── 管理所有配置的读写
├── 业务层
│   ├── 域名检测 (domain_checker.py)
│   └── 告警通知 (telegram_notifier.py)
├── 交互层 (telegram_bot.py)
│   └── 处理 Telegram 命令
└── 主控层 (main.py)
    └── 协调各个模块
```

## 核心模块详解

### 1. config_manager.py - 配置管理器

**主要功能：**
- 线程安全的配置读写
- 配置项验证
- 自动备份和恢复

**关键技术点：**
```python
# 使用 threading.RLock 实现线程安全
self.lock = threading.RLock()  # 可重入锁

# 点号路径访问嵌套配置
config.get('telegram.bot_token')  # 获取嵌套值

# 原子操作保证数据完整性
1. 重命名原文件为备份
2. 写入新文件
3. 删除备份（成功时）或恢复（失败时）
```

**学习重点：**
- 线程安全编程
- JSON 文件操作
- 错误处理和恢复机制

### 2. domain_checker.py - 域名检测器

**主要功能：**
- 异步并发检测
- 错误分类
- 自动重试

**关键技术点：**
```python
# 使用 httpx 进行异步 HTTP 请求
async with httpx.AsyncClient() as client:
    response = await client.get(url)

# 并发执行多个检测
tasks = [check_domain(url) for url in urls]
results = await asyncio.gather(*tasks)

# 错误分类（使用枚举）
class CheckStatus(Enum):
    SUCCESS = "success"
    DNS_ERROR = "dns_error"
    # ...
```

**学习重点：**
- asyncio 异步编程
- HTTP 客户端使用
- 异常处理和分类

### 3. telegram_notifier.py - 通知模块

**主要功能：**
- 发送 Telegram 消息
- 告警冷却控制
- 恢复通知

**关键技术点：**
```python
# 冷却期控制
last_notification_time: Dict[str, datetime]

# Markdown 格式化消息
message = f"**粗体** `代码` [链接](url)"

# 连续失败计数
failure_count: Dict[str, int]
```

**学习重点：**
- Telegram Bot API
- 时间控制逻辑
- 消息格式化

### 4. telegram_bot.py - 命令处理器

**主要功能：**
- 监听 Telegram 命令
- 权限控制
- 命令路由

**关键技术点：**
```python
# 长轮询获取更新
response = await client.get(
    f"{api_url}/getUpdates",
    params={"offset": last_id + 1, "timeout": 25}
)

# 命令映射
self.commands = {
    '/help': self.cmd_help,
    '/add': self.cmd_add_domain,
    # ...
}

# 权限检查
if not self.is_authorized(user_id):
    return
```

**学习重点：**
- Telegram Bot 长轮询
- 命令模式设计
- 权限管理

### 5. main.py - 主程序

**主要功能：**
- 组件生命周期管理
- 任务调度
- 信号处理

**关键技术点：**
```python
# 信号处理
signal.signal(signal.SIGINT, self._signal_handler)

# 异步任务管理
self.check_task = asyncio.create_task(self.run_check())

# 优雅停止
tasks = [task for task in [...] if not task.done()]
await asyncio.gather(*tasks, return_exceptions=True)
```

**学习重点：**
- asyncio 任务管理
- 信号处理
- 组件协调

## 关键设计模式

### 1. 单例模式变体
ConfigManager 通过传递实例实现共享配置

### 2. 回调模式
```python
bot.set_callbacks(
    check=self.run_check,
    stop=self.stop
)
```

### 3. 状态机模式
CheckStatus 枚举管理域名状态

### 4. 命令模式
命令映射到处理函数

## 异步编程要点

### 基础概念
```python
# 协程定义
async def function():
    await asyncio.sleep(1)

# 并发执行
await asyncio.gather(task1, task2)

# 创建任务
task = asyncio.create_task(coroutine)

# 取消任务
task.cancel()
```

### 常见陷阱
1. **忘记 await**
```python
# 错误
async_function()  # 不会执行

# 正确
await async_function()
```

2. **同步阻塞**
```python
# 错误
time.sleep(1)  # 阻塞事件循环

# 正确
await asyncio.sleep(1)
```

3. **任务泄露**
```python
# 确保任务被清理
if task and not task.done():
    task.cancel()
```

## 配置管理最佳实践

### 1. 配置验证
```python
if minutes < 1 or minutes > 1440:
    return False, "无效范围"
```

### 2. 默认值处理
```python
config.get('key', default_value)
```

### 3. 原子操作
使用备份确保配置不丢失

## 错误处理策略

### 1. 分层处理
- 底层：捕获具体异常
- 中层：转换为业务错误
- 顶层：记录日志和通知

### 2. 重试机制
```python
for attempt in range(retry_count):
    try:
        return await operation()
    except Exception:
        if attempt < retry_count - 1:
            await asyncio.sleep(retry_delay)
```

### 3. 降级策略
配置加载失败时使用默认配置

## 日志最佳实践

### 日志级别使用
- DEBUG: 详细调试信息
- INFO: 正常运行信息
- WARNING: 警告但不影响运行
- ERROR: 错误需要关注

### 结构化日志
```python
self.logger.info(f"域名 {domain} 检查完成")
```

## 安全考虑

### 1. Token 保护
- 不要提交到版本控制
- 使用环境变量（生产环境）

### 2. 权限控制
- admin_users 列表
- 空列表时所有人可操作（避免锁定）

### 3. 输入验证
- URL 格式验证
- 参数范围检查

## 性能优化

### 1. 并发检测
同时检测所有域名，而不是顺序检测

### 2. 连接复用
httpx.AsyncClient 自动复用连接

### 3. 避免重复检查
```python
if self.check_task and not self.check_task.done():
    return  # 跳过
```

## 扩展建议

### 1. 数据持久化
- 添加数据库支持
- 历史数据统计

### 2. 更多通知渠道
- 邮件通知
- Webhook 支持

### 3. Web 界面
- 实时监控面板
- 历史趋势图表

### 4. 高级功能
- 自定义检查规则
- 响应时间监控
- SSL 证书过期提醒

## 调试技巧

### 1. 日志调试
```python
# 临时提高日志级别
logging.getLogger().setLevel(logging.DEBUG)
```

### 2. 断点调试
```python
import pdb; pdb.set_trace()  # 同步代码
# 异步代码需要使用 aiodebugger
```

### 3. 打印调试
```python
print(f"[DEBUG] {variable}")
```

## 常见问题解决

### 1. "Event loop is closed"
确保使用 asyncio.run() 而不是手动管理事件循环

### 2. "This event loop is already running"
不要在 Jupyter 中直接运行，或使用 nest_asyncio

### 3. Telegram 连接失败
- 检查网络是否能访问 Telegram API
- 验证 Token 格式
- 确认 Bot 已加入群组

## 学习路径建议

1. **基础阶段**
   - 理解 Python asyncio
   - 学习 JSON 操作
   - 了解 HTTP 协议

2. **进阶阶段**
   - 掌握异步编程模式
   - 学习 Telegram Bot API
   - 理解线程安全

3. **高级阶段**
   - 设计模式应用
   - 性能优化
   - 系统架构设计

## 代码维护建议

1. **添加新功能前**
   - 理解现有架构
   - 遵循现有模式
   - 添加适当注释

2. **修改配置项**
   - 更新 ConfigManager
   - 更新配置文件示例
   - 更新文档

3. **调试问题**
   - 查看日志文件
   - 使用 /config 命令查看配置
   - 逐步排查各模块

## 总结

这个项目展示了一个完整的 Python 异步应用架构，包含了配置管理、异步任务、API 集成、错误处理等多个方面。通过学习这个项目，您可以掌握：

1. Python 异步编程
2. Telegram Bot 开发
3. 配置管理最佳实践
4. 错误处理和日志记录
5. 模块化设计

建议按照模块逐个学习，先理解每个模块的功能，再研究它们如何协作。实践中可以尝试添加新功能来加深理解。